---
title: "Waterbird data cleaning and prep for analysis"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

##

The first of 4 steps to prep waterbird data for use.  

The files waterbird_cleaning1... thru 4... should be run in order to yield a cleaned data file that has lumped birds split into constituent species where this can be done reasonably, and has any negative tallies reconciled.  

This file reads waterbird data from access and does basic house-keeping on variable names.  


These code files use functions which are defined in waterbird_utility_functions.R and bird_utility_functions.r.  

As of 2019 data are in a new relational Access db. A query from db now yields data in longer format with species and count fields, rather than wide with a field for each species.  

# A guide to column names  
I tried to make field names here as similar as possible to those in the old xlsx files.  

Pooled and single species data are treated the same until the expand_pooled() function is called; thus before then count and both section.sum... fields have data for single species and pooled birds. After expand_pooled() is called and the result is joined back tot he single species data, then single species and pooled data live in different field names
#-
 pooled.alpha.code = Pooled group (keeping as alpha.code for consistency with all other bird name operations)

# section.tally = tallied (may contain negatives) of each constituent species by section
# section.final = final (no negatives) of each constituent species by section
# section.all.constituents = total of all constituents in a given pooled group, by section
# section.proportion = proportion of section.all.constituents made up of given constituent species, by section
# bay.total = final (no negatives) of each constituent species for the entire bay
# bay.all.constituents = total of all constituents in a given pooled group for the entire bay
# pooled.section.tally = tallied (may contain negatives) of pooled group birds by section
# pooled.section.final = final (no negatives) of pooled group birds by section
# pooled.bay.total = final (no negatives) of pooled group birds for the entire bay


First load packages and setup
```{r}
library(tidyverse)
library(lubridate)
library(birdnames)
library(here)
library(RODBC)

useless_groupies <- c("AMCOGRSCLESCBUFF", "COMERBME", "GOOSE", "MERG", "MURRELET", "SWAN", "UNTE", "DUCK")

useful_groupies <- c("LOON", "RTPALO", "CORM", "HEGR", "WCGR", "PCLO")

options("scipen"=999)
source(here("code/utils.r"))
source(here("code/waterbird_cleaning2_split_groups.r"))
source(here("code/waterbird_cleaning3_reconcile_negatives.r"))

custom_bird_list <- readRDS("C:/Users/scott.jennings/Documents/Projects/birdnames_support/data/custom_bird_list")

wbird_keep_taxa <- c("AMCOGRSCLESCBUFF", "AMCO", "COGA", "Anseriformes", "Alcidae", "Gaviidae", "Pelecanidae", "Podicipediformes", "Sterninae", "Suliformes")
#wbird_keep_taxa_gulls <- c("Anseriformes", "Alcidae", "Laridae", "Gaviidae", "Pelecanidae", "Podicipediformes", "Suliformes")
```

Next do some basic data management in prep for splitting POOLED and reconciling negatives.
```{r}
# this is the path for the access database
db <- "C:/Users/scott.jennings/Documents/Projects/water_birds/ACR_waterbird_data_management/data_files/waterbirds_v2.0.accdb"

spp_table <- read_species_table(db) 

wbirds <- query_waterbirds(db) %>% 
  clean_waterbirds() %>% 
  sppindex_to_alpha(spp_table = spp_table) %>%
  mutate(alpha.code = update_alpha(alpha.code)) %>% # from birdnames
  fix_precount_block_names() %>% 
  bird_taxa_filter(keep_taxa = wbird_keep_taxa) %>% # from birdnames
  separate(block, into = c("transect", "section"), remove = F) %>% 
  mutate(section = gsub("sec", "", section))  %>% 
  select(date, block, section, transect, alpha.code, count) # we only need a few columns

```

From here, you may wish to save wbirds if you want to use unprocessed data or want to do something with the data at the block level.  

The next step is to sum the number of birds across each block within the four sections of the bay, using a function defined in utils.R. In the final mutate() line here we add a column "group.spp" for constituent species in each POOLED group, if applicable.  
sum_section_tallies_finals() incorporates birds counted in the precount zones into the appropriate sections:
bivalve, millertonbivalve and inverness into section 1
cypressgrove into section 2 
walkercreek into section 3
```{r}
section_tallies_finals <- wbirds %>%  
  sum_section_tallies_finals() %>%
  mutate(group.spp = translate_bird_names(alpha.code, "alpha.code", "group.spp"))
```


Once we have count data summarized to section, we can proceed with splitting POOLED observations.

# The logic of splitting is as follows:
* There are several species of waterbirds that may not be identified to species but that can be assigned to a POOLED group (e.g. LOON, CORM).  

* POOLED birds are allocated to the constituent species of that POOLED group based on the ratios of positively identified birds in each constituent species. Allocation is only done if the number of positively identified birds in the group is greater than the number of undifferentiated birds.

* The bay is divided into 4 sections, numbered from south to north

* If there are enough identified birds at the section scale, then the ratio of IDed birds in each species counted in that section is used to divvy the lumped birds. The group cutoff value is 50 for grebes, 100 for all other groups.

* If there are not enough IDed birds in the Section, then the ratio for IDed birds across the entire Bay is used. NOTE: IT APPEARS KELLY AND TAPPAN 1998 DID NOT DO THIS EXTRA STEP. DOING THIS EXTRA STEP INCLUDES MORE INDIVIDUAL BIRDS, BUT AT THE COST OF MORE LIBERAL ASSUMPTIONS ABOUT RATIOS OF IDENTIFIED AND UNIDENTIFIED BIRDS BEING CONSTANT THROUGHOUT THE ENTIRE BAY. THERE ARE AT LEAST SOME OCCASIONS WHERE THE CONSTITUENT SPP RATIO IN THE SECTION WITH POOLED BIRDS IS QUITE DIFFERENT THAN THE RATIO IN THE WHOLE BAY (E.G., ) THE FOLLOWING CODE INDICATES WHETHER AN ALLOCATION WAS MADE BASED ON SECTION OR BAY RATIOS, SO THAT THE USER CAN DECIDE WHICH DATA TO INCLUDE IN ANALYSIS




Next we need to calculate the ratios of constituent species in each section and in the entire bay on the days that we had POOLED birds.

```{r}

constituents_by_group <- section_tallies_finals %>% 
  make_pooled_date_constituents() %>% 
  calc_section_constituent_sum_proportion() %>%  # total constituent species in each section (e.g. total DCCO, BRCO, PECO in section 3)
  calc_bay_constituent_sum_proportion()
# warning about missing pieces is expected
```


Then peel off just the POOLED bird data, join with the ratio table, and allocate POOLED birds to constituent species based on the appropriate ratio.
```{r}

pooled <- section_tallies_finals %>% 
   get_pooled()

# now arrange constituent sums and ratios alongside the appropriate pooled sums to divy the pooled
allocated_pooled <- allocate_pooled(constituents_by_group, pooled) %>% 
  arrange(date, section, pooled.alpha.code, alpha.code)

```

A quick summary to view how many of each POOLED group were allocated by section of bay ratio or remain unallocated.  
```{r}

allocated_pooled %>% 
    filter(allocation.scale != "no.allocation") %>%  
    group_by(pooled.alpha.code, allocation.scale)%>% 
    replace(., is.na(.), 0) %>% 
    summarise(total = sum(abs(allocated.tally))) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = pooled.alpha.code, values_from = total, names_from = allocation.scale)%>% 
  full_join(., allocated_pooled %>%
              filter(allocation.scale == "no.allocation") %>%
              distinct(date, section, pooled.alpha.code, pooled.section.tally) %>%
              group_by(pooled.alpha.code) %>%
              summarise(no.allocation = sum(abs(pooled.section.tally))) %>%
              ungroup()) %>% 
  select(pooled.alpha.code, section, bay, no.allocation) %>% 
  view()

```

Then a function to combine the split pooled, unsplit pooled, and unpooled birds back together, then recalculate the summed section tallies and finals with the allocated birds 

```{r}

split_unsplit_unpooled <- combine_split_unsplit_unpooled(section_tallies_finals, allocated_pooled) %>% 
  sum_section_tallies_finals()
```


Finally, we can deal with any net negatives that need to be carried forward to subsequent sections.

```{r}
filter(wbirds, count < -100) %>% 
  count(alpha.code, block) %>% 
  pivot_wider(id_cols = alpha.code, values_from = n, names_from = block) %>% 
  select(alpha.code, contains("1"), contains("2"), contains("3"), contains("4")) %>% 
  view()

```

```{r}

#negatives_carried <- readRDS("data_files/working_rds/wbirds_sppid_allocated") %>% 
negatives_carried <- split_unsplit_unpooled %>% 
  widen_section_tallies() %>% 
  calc_carried_forward() %>% 
  calc_bay_sum()


saveRDS(negatives_carried, "data_files/working_rds/negatives_carried")

```

